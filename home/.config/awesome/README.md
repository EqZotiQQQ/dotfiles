# rules
Сигналы и биндинги хранятся рядом (в этом же или соседнем файле) с тем местом, где они используются. Не централизованно.

widget file structure:
- widgets
-- widget_1
--- init.lua
--- glob_bindings.lua
--- client_bindings.lua



# Я заебался постоянно выписывать что за сигнал и зачем он нужен

# request::default_layouts
1. Этот сигнал нужен для получения списка доступных раскладок (layout), которые могут быть применены к тегам (tag) в awesomewm.
2. Этот сигнал вызывается внутренними механизмами awesomewm при инициализации тегов или при запросе списка раскладок.
3. Этот сигнал может быть полезен в случае, когда вы хотите:
   - Изменить стандартный набор раскладок
   - Добавить свои кастомные раскладки
   - Ограничить доступные раскладки для определенных тегов
4. Схожие сигналы и их очень короткое описание:
   - `request::default_tags` - запрос стандартных тегов
   - `request::layout` - запрос конкретной раскладки
5. Как это работает:
   Когда awesomewm нуждается в списке раскладок (например, при создании новых тегов), он испускает этот сигнал. Модули или конфигурация могут подключиться к этому сигналу и вернуть свой список раскладок. По умолчанию awesomewm использует стандартный набор раскладок (floating, max, tile и другие).
6. Пример:
```lua
-- В вашем rc.lua
awful.tag.add("1", {
    -- ...
    layouts = awful.layout.layouts, -- стандартные раскладки
})

-- Если нужно изменить раскладки глобально
connect_signal("request::default_layouts", function()
    return {
        awful.layout.suit.floating,
        awful.layout.suit.tile,
        -- ваш кастомный layout
    }
end)
```


# request::display_error  
1. Этот сигнал нужен для обработки и отображения ошибок в awesomewm, когда возникает критическая или неожиданная ситуация.  
2. Этот сигнал вызывается внутренними механизмами awesomewm в случаях:  
   - Ошибки в конфигурации (`rc.lua`)  
   - Сбоев в работе Lua-кода  
   - Проблем с клиентами (окнами)  
   - Других необработанных исключений  
3. Этот сигнал может быть полезен в случае:  
   - Кастомизации вывода ошибок (например, вместо стандартного уведомления — всплывающее окно)  
   - Логирования ошибок в файл  
   - Гибкой обработки сбоев без падения WM  
4. Схожие сигналы и их очень короткое описание:  
   - `debug::error` – сигнал для отладки ошибок (более низкоуровневый)  
   - `request::exit` – запрос на выход из awesomewm (может вызываться при фатальных ошибках)  
5. Как это работает:  
   Когда awesomewm сталкивается с ошибкой, он генерирует сигнал `request::display_error`, передавая текст ошибки и дополнительную информацию. Подключенные обработчики могут либо:  
   - Отобразить ошибку пользователю (например, через `naughty.notify`)  
   - Проигнорировать её (не рекомендуется)  
   - Попытаться восстановить работу  
6. Пример:  
```lua  
-- Добавляем красивый вывод ошибок через уведомления  
client.connect_signal("request::display_error", function(error, context)  
    naughty.notify({  
        title = "Ошибка в awesomewm",  
        text = "Произошла ошибка: " .. tostring(error),  
        timeout = 10,  
        urgency = "critical",  
    })  
end)  

-- Или логируем ошибки в файл  
client.connect_signal("request::display_error", function(error, context)  
    local log_file = io.open("/tmp/awesomewm_errors.log", "a")  
    if log_file then  
        log_file:write(os.date("%Y-%m-%d %H:%M:%S") .. " | " .. tostring(error) .. "\n")  
        log_file:close()  
    end  
end)  
```

# request::wallpaper  
1. Этот сигнал нужен для установки и управления обоями рабочего стола (wallpaper) в awesomewm.  
2. Этот сигнал вызывается:  
   - При инициализации экрана (при запуске awesomewm)  
   - При изменении размера/разрешения экрана  
   - При добавлении/удалении экранов в multi-screen конфигурации  
   - Вручную через вызов `screen.emit_signal("request::wallpaper", screen)`  
3. Этот сигнал может быть полезен в случае:  
   - Динамической смены обоев в зависимости от экрана  
   - Применения разных обоев для разных мониторов  
   - Использования сложных эффектов (градиенты, шаблоны) вместо статичного изображения  
4. Схожие сигналы и их очень короткое описание:  
   - `property::geometry` - изменение геометрии экрана  
   - `request::desktop_decoration` - запрос декораций рабочего стола  
5. Как это работает:  
   Сигнал испускается для каждого экрана (`screen`), когда awesomewm требует обновить обои. Обработчик получает объект экрана и должен установить wallpaper через `gears.wallpaper`.  
6. Пример:  
```lua
-- Базовый пример с установкой изображения
screen.connect_signal("request::wallpaper", function(s)
    gears.wallpaper.maximized("/path/to/wallpaper.jpg", s, true)
end)

-- Разные обои для разных экранов
screen.connect_signal("request::wallpaper", function(s)
    local wallpapers = {
        "/path/wall1.jpg",
        "/path/wall2.jpg"
    }
    gears.wallpaper.maximized(wallpapers[s.index] or wallpapers[1], s, true)
end)

-- Динамические обои через cairo
screen.connect_signal("request::wallpaper", function(s)
    gears.wallpaper.set(gears.color("#303030"), s)
end)
```

# request::desktop_decoration
1. Этот сигнал нужен для добавления различных элементов оформления рабочего стола (декораций), таких как виджеты, элементы интерфейса или фоновые компоненты.  
2. Этот сигнал вызывается:  
   - При инициализации каждого экрана  
   - При подключении нового монитора в multi-screen конфигурации  
   - Вручную через `screen.emit_signal("request::desktop_decoration", screen)`  
3. Этот сигнал может быть полезен в случае:  
   - Добавления кастомных виджетов на рабочий стол  
   - Создания информационных панелей или элементов интерфейса  
   - Размещения элементов, которые должны появляться только на определенных экранах  
4. Схожие сигналы и их очень короткое описание:  
   - `request::wallpaper` - запрос установки обоев рабочего стола  
   - `request::taglist` - запрос создания taglist для экрана  
   - `request::tasklist` - запрос создания tasklist для экрана  
5. Как это работает:  
   Сигнал испускается для каждого экрана при его инициализации. В обработчике вы можете добавлять различные wibox-виджеты и элементы непосредственно на рабочий стол. AwesomeWM автоматически вызывает этот сигнал при создании экрана.  
6. Пример:  
```lua
screen.connect_signal("request::desktop_decoration", function(s)
    -- Создаем простой текст-виджет на рабочем столе
    local desktop_widget = wibox.widget {
        widget = wibox.widget.textbox,
        text = "Добро пожаловать в AwesomeWM",
        font = "Sans 24",
        valign = "center",
        align = "center"
    }
    
    -- Размещаем виджет по центру экрана
    awful.placement.centered(desktop_widget, {
        parent = s,
        honor_workarea = true
    })
    
    -- Можно добавить другие элементы, например:
    -- - Часы
    -- - Информационные панели
    -- - Системные мониторы
end)
```
